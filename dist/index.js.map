{
  "version": 3,
  "sources": ["../src/index.ts", "../src/git.ts", "../src/exec.ts", "../src/logger.ts", "../src/commands.ts", "../src/autorun.ts"],
  "sourcesContent": ["import { Command } from 'commander';\nimport { checkGitRepo } from './git.js';\nimport { createWorktree, listWorktrees, removeWorktree, pruneWorktrees } from './commands.js';\nimport { error, setVerbose } from './logger.js';\nimport type { CreateWorktreeOptions } from './commands.js';\n\nconst program = new Command();\n\nprogram\n  .name('workspace')\n  .description('Easily create isolated workspaces that fit your git workflow \u2014 comes with automatic and configurable setup detection. Perfect for AI sandboxed coding and testing.')\n  .version('0.0.1')\n  .option('-v, --verbose', 'Show detailed operation logs');\n\n// Main command: create worktree\nprogram\n  .argument('[branch]', 'Branch name to create worktree for')\n  .option('-n, --no-setup', 'Skip setup script (fastest, git operations only)')\n  .option('-s, --setup <path>', 'Use custom setup script')\n  .option('-b, --base <branch>', 'Create new branch from custom base (default: main)')\n  .action((branch: string | undefined, options: any) => {\n    try {\n      if (options.verbose) setVerbose(true);\n      checkGitRepo();\n\n      if (!branch) {\n        program.help();\n        return;\n      }\n\n      // Convert Commander's option naming (--no-setup becomes setup: false)\n      const createOptions: CreateWorktreeOptions = {\n        skipSetup: options.setup === false,\n        setupScript: typeof options.setup === 'string' ? options.setup : undefined,\n        baseBranch: options.base,\n      };\n\n      createWorktree(branch, createOptions);\n    } catch (err) {\n      if (err instanceof Error) {\n        error(err.message);\n      }\n      process.exit(1);\n    }\n  });\n\n// List command\nprogram\n  .command('list')\n  .alias('ls')\n  .description('List all worktrees')\n  .option('-v, --verbose', 'Show detailed operation logs')\n  .action((options: any) => {\n    try {\n      if (options.verbose) setVerbose(true);\n      checkGitRepo();\n      listWorktrees();\n    } catch (err) {\n      if (err instanceof Error) {\n        error(err.message);\n      }\n      process.exit(1);\n    }\n  });\n\n// Remove command\nprogram\n  .command('remove <name>')\n  .alias('rm')\n  .alias('delete')\n  .description('Remove a worktree')\n  .option('-v, --verbose', 'Show detailed operation logs')\n  .action((name: string, options: any) => {\n    try {\n      if (options.verbose) setVerbose(true);\n      checkGitRepo();\n      removeWorktree(name);\n    } catch (err) {\n      if (err instanceof Error) {\n        error(err.message);\n      }\n      process.exit(1);\n    }\n  });\n\n// Prune command\nprogram\n  .command('prune')\n  .alias('clean')\n  .description('Clean up stale worktrees')\n  .option('-v, --verbose', 'Show detailed operation logs')\n  .action((options: any) => {\n    try {\n      if (options.verbose) setVerbose(true);\n      checkGitRepo();\n      pruneWorktrees();\n    } catch (err) {\n      if (err instanceof Error) {\n        error(err.message);\n      }\n      process.exit(1);\n    }\n  });\n\nprogram.parse();\n", "import { existsSync, readFileSync, appendFileSync, writeFileSync } from 'node:fs';\nimport { join } from 'node:path';\nimport { exec, execQuiet, execInteractive } from './exec.js';\nimport { info, detail, warning, success, error } from './logger.js';\n\nexport const WORKTREE_DIR = '.worktree';\nexport const DEFAULT_BASE_BRANCH = 'main';\n\nexport interface BranchResolution {\n  type: 'remote' | 'local' | 'new';\n  foundBranch: string;\n  cleanBranchName: string;\n}\n\n// Git validation\n\nexport function checkGitRepo(): void {\n  const result = execQuiet('git rev-parse --git-dir');\n  if (!result) {\n    throw new Error('Not a git repository');\n  }\n}\n\nexport function getProjectRoot(): string {\n  return exec('git rev-parse --show-toplevel');\n}\n\n// Branch operations\n\nexport function resolveBranch(branch: string): BranchResolution {\n  let remoteCandidate: string;\n  let cleanBranchName: string;\n\n  // Build remote candidate first (before stripping prefixes)\n  if (branch.startsWith('origin/')) {\n    remoteCandidate = branch;\n    cleanBranchName = branch.replace('origin/', '');\n  } else if (branch.startsWith('remotes/origin/')) {\n    remoteCandidate = branch.replace('remotes/', '');\n    cleanBranchName = branch.replace('remotes/origin/', '');\n  } else {\n    // For anything else (claude/foo, feature/bar, etc.), prepend origin/\n    remoteCandidate = `origin/${branch}`;\n    cleanBranchName = branch;\n  }\n\n  // Check remote, then local, then create new\n  if (branchExists(remoteCandidate)) {\n    info(`Found remote branch: ${remoteCandidate}`);\n    return {\n      type: 'remote',\n      foundBranch: remoteCandidate,\n      cleanBranchName,\n    };\n  } else if (branchExists(cleanBranchName)) {\n    info(`Found local branch: ${cleanBranchName}`);\n    return {\n      type: 'local',\n      foundBranch: cleanBranchName,\n      cleanBranchName,\n    };\n  } else {\n    info(`Branch '${cleanBranchName}' not found on remote or locally`);\n    info('Will create new branch from base');\n    return {\n      type: 'new',\n      foundBranch: '',\n      cleanBranchName,\n    };\n  }\n}\n\nexport function branchExists(branch: string): boolean {\n  const result = execQuiet(`git rev-parse --verify ${branch}`);\n  return result !== '';\n}\n\nexport function getBranchRef(branch: string): string {\n  return execQuiet(`git rev-parse --verify ${branch}`);\n}\n\nexport function getBranchName(worktreePath: string): string {\n  return execQuiet(`cd \"${worktreePath}\" && git rev-parse --abbrev-ref HEAD`);\n}\n\nexport function getBranchInfo(worktreePath: string): { branch: string; tracking?: string } {\n  const branch = getBranchName(worktreePath);\n  const tracking = execQuiet(\n    `cd \"${worktreePath}\" && git rev-parse --abbrev-ref --symbolic-full-name @{u} 2>/dev/null`\n  ).replace(/^origin\\//, '');\n\n  return {\n    branch,\n    tracking: tracking && tracking !== '@{u}' ? tracking : undefined,\n  };\n}\n\nexport function fetchRemote(): void {\n  const result = execQuiet('git fetch --quiet origin');\n  if (result === '') {\n    // Fetch succeeded (no output expected)\n    return;\n  }\n}\n\n// Worktree paths\n\nexport function sanitizeBranchName(branch: string): string {\n  return branch.replace(/[^a-zA-Z0-9_-]/g, '-');\n}\n\nexport function getWorktreeName(branch: string): string {\n  return sanitizeBranchName(branch.replace(/^origin\\//, ''));\n}\n\nexport function getWorktreePath(worktreeDir: string, branch: string): string {\n  const name = getWorktreeName(branch);\n  return join(worktreeDir, name);\n}\n\n// Worktree creation handlers\n\nfunction ensureTracking(\n  worktreePath: string,\n  branchName: string,\n  remoteBranch: string\n): void {\n  const upstream = execQuiet(\n    `cd \"${worktreePath}\" && git rev-parse --abbrev-ref --symbolic-full-name @{u}`\n  );\n  if (!upstream) {\n    info(`Setting up tracking: ${branchName} -> ${remoteBranch}`);\n    exec(`cd \"${worktreePath}\" && git branch --set-upstream-to=\"${remoteBranch}\"`);\n  }\n}\n\nfunction createWorktreeWithExistingBranch(\n  worktreePath: string,\n  branchName: string,\n  remoteBranch: string\n): void {\n  info(`Using existing local branch: ${branchName}`);\n  exec(`git worktree add \"${worktreePath}\" \"${branchName}\"`);\n  ensureTracking(worktreePath, branchName, remoteBranch);\n  success('Worktree created!');\n  info(`Branch: ${branchName} (tracking ${remoteBranch})`);\n}\n\nfunction createWorktreeWithNewTrackingBranch(\n  worktreePath: string,\n  branchName: string,\n  remoteBranch: string\n): void {\n  info(`Creating local tracking branch: ${branchName} -> ${remoteBranch}`);\n  exec(`git worktree add -b \"${branchName}\" \"${worktreePath}\" \"${remoteBranch}\"`);\n  exec(`cd \"${worktreePath}\" && git branch --set-upstream-to=\"${remoteBranch}\"`);\n  success('Worktree created!');\n  info(`Branch: ${branchName} (tracking ${remoteBranch})`);\n}\n\nexport function createFromRemoteBranch(\n  worktreePath: string,\n  resolution: BranchResolution\n): void {\n  const trackingBranchName = resolution.foundBranch.replace('origin/', '');\n\n  if (branchExists(trackingBranchName)) {\n    createWorktreeWithExistingBranch(worktreePath, trackingBranchName, resolution.foundBranch);\n  } else {\n    createWorktreeWithNewTrackingBranch(worktreePath, trackingBranchName, resolution.foundBranch);\n  }\n}\n\nexport function createFromLocalBranch(\n  worktreePath: string,\n  resolution: BranchResolution\n): void {\n  info(`Using existing local branch: ${resolution.foundBranch}`);\n  exec(`git worktree add \"${worktreePath}\" \"${resolution.foundBranch}\"`);\n  success('Worktree created!');\n  info(`Branch: ${resolution.foundBranch}`);\n}\n\nexport function createNewBranch(\n  worktreePath: string,\n  resolution: BranchResolution,\n  baseBranchOption?: string\n): void {\n  const baseBranch = baseBranchOption || DEFAULT_BASE_BRANCH;\n\n  // Verify base branch exists\n  if (!branchExists(baseBranch)) {\n    error(`Base branch not found: ${baseBranch}`);\n    info('Available branches:');\n    execInteractive('git branch -a | head -20');\n    process.exit(1);\n  }\n\n  const branchRef = getBranchRef(baseBranch);\n  info(`Creating new branch '${resolution.cleanBranchName}' from: ${baseBranch}`);\n\n  exec(`git worktree add -b \"${resolution.cleanBranchName}\" \"${worktreePath}\" \"${branchRef}\"`);\n  success('Worktree created!');\n  info(`Branch: ${resolution.cleanBranchName} (new from ${baseBranch})`);\n}\n\n// Gitignore management\n\nexport function ensureGitignore(projectRoot: string, worktreeDir: string): void {\n  const gitignorePath = join(projectRoot, '.gitignore');\n  const pattern = `${worktreeDir}/`;\n\n  if (!existsSync(gitignorePath)) {\n    warning('.gitignore not found, creating one');\n    writeFileSync(gitignorePath, `${pattern}\\n`);\n    success(`Added ${pattern} to .gitignore`);\n    return;\n  }\n\n  const content = readFileSync(gitignorePath, 'utf8');\n  const regex = new RegExp(`^${worktreeDir}/?\\$`, 'm');\n\n  if (!regex.test(content)) {\n    warning(`${pattern} not found in .gitignore`);\n    appendFileSync(gitignorePath, `\\n# git worktrees\\n${pattern}\\n`);\n    success(`Added ${pattern} to .gitignore`);\n  }\n}\n", "import { execSync, ExecSyncOptions } from 'node:child_process';\nimport { error } from './logger.js';\n\nexport function exec(command: string, options?: ExecSyncOptions): string {\n  try {\n    const result = execSync(command, {\n      encoding: 'utf8',\n      stdio: ['inherit', 'pipe', 'pipe'],\n      ...options,\n    });\n    return typeof result === 'string' ? result.trim() : result.toString().trim();\n  } catch (err) {\n    const execError = err as { status?: number; stderr?: Buffer };\n    error(`Command failed: ${command}`);\n    if (execError.stderr) {\n      error(execError.stderr.toString());\n    }\n    process.exit(execError.status ?? 1);\n  }\n}\n\nexport function execQuiet(command: string): string {\n  try {\n    return execSync(command, {\n      encoding: 'utf8',\n      stdio: ['pipe', 'pipe', 'pipe'],\n    }).trim();\n  } catch {\n    return '';\n  }\n}\n\nexport function execInteractive(command: string): void {\n  try {\n    execSync(command, {\n      stdio: 'inherit',\n    });\n  } catch (err) {\n    const execError = err as { status?: number };\n    process.exit(execError.status ?? 1);\n  }\n}\n", "import chalk from 'chalk';\n\nlet verboseMode = false;\n\nexport function setVerbose(verbose: boolean): void {\n  verboseMode = verbose;\n}\n\nexport function info(message: string): void {\n  if (verboseMode) {\n    console.log(chalk.blue('\u2139'), message);\n  }\n}\n\n// Indented detail lines (no icon, always shown)\nexport function detail(message: string): void {\n  console.log(`  ${message}`);\n}\n\nexport function success(message: string): void {\n  console.log(chalk.green('\u2713'), message);\n}\n\nexport function warning(message: string): void {\n  console.log(chalk.yellow('\u26A0'), message);\n}\n\nexport function error(message: string): void {\n  console.error(chalk.red('\u2717'), message);\n}\n\n// Lightweight spinner (no dependencies needed)\ninterface Spinner {\n  start(): void;\n  succeed(message?: string): void;\n  fail(message?: string): void;\n  stop(): void;\n}\n\nexport function createSpinner(message: string): Spinner {\n  const frames = ['\u280B', '\u2819', '\u2839', '\u2838', '\u283C', '\u2834', '\u2826', '\u2827', '\u2807', '\u280F'];\n  let frameIndex = 0;\n  let interval: NodeJS.Timeout | null = null;\n  let isRunning = false;\n\n  const render = (): void => {\n    const frame = frames[frameIndex % frames.length];\n    process.stdout.write(`\\r${chalk.cyan(frame)} ${message}`);\n    frameIndex++;\n  };\n\n  return {\n    start(): void {\n      if (isRunning) return;\n      isRunning = true;\n      render();\n      interval = setInterval(render, 80);\n    },\n\n    succeed(finalMessage?: string): void {\n      if (!isRunning) return;\n      isRunning = false;\n      if (interval) clearInterval(interval);\n      const msg = finalMessage || message;\n      // Pad with spaces to clear any leftover spinner characters\n      const padding = Math.max(0, message.length - msg.length + 20);\n      process.stdout.write(`\\r${chalk.green('\u2713')} ${msg}${' '.repeat(padding)}\\n`);\n    },\n\n    fail(finalMessage?: string): void {\n      if (!isRunning) return;\n      isRunning = false;\n      if (interval) clearInterval(interval);\n      const msg = finalMessage || message;\n      // Pad with spaces to clear any leftover spinner characters\n      const padding = Math.max(0, message.length - msg.length + 20);\n      process.stdout.write(`\\r${chalk.red('\u2717')} ${msg}${' '.repeat(padding)}\\n`);\n    },\n\n    stop(): void {\n      if (!isRunning) return;\n      isRunning = false;\n      if (interval) clearInterval(interval);\n      process.stdout.write('\\r');\n    },\n  };\n}\n", "import { existsSync, mkdirSync } from 'node:fs';\nimport { join } from 'node:path';\nimport {\n  WORKTREE_DIR,\n  getWorktreeName,\n  getWorktreePath,\n  getProjectRoot,\n  ensureGitignore,\n  fetchRemote,\n  resolveBranch,\n  createFromRemoteBranch,\n  createFromLocalBranch,\n  createNewBranch,\n  getBranchInfo,\n} from './git.js';\nimport { runSetup, type SetupMode } from './autorun.js';\nimport { exec, execQuiet, execInteractive } from './exec.js';\nimport { info, detail, warning, success, error, createSpinner } from './logger.js';\n\nexport interface CreateWorktreeOptions {\n  skipSetup?: boolean;\n  setupScript?: string;\n  baseBranch?: string;\n}\n\ninterface WorktreePaths {\n  projectRoot: string;\n  dirName: string;\n  worktreePath: string;\n}\n\n// Path preparation\n\nfunction prepareWorktreePaths(branch: string): WorktreePaths {\n  const projectRoot = getProjectRoot();\n  const dirName = getWorktreeName(branch);\n  const worktreePath = getWorktreePath(join(projectRoot, WORKTREE_DIR), branch);\n  return { projectRoot, dirName, worktreePath };\n}\n\n// Prerequisite setup\n\nfunction ensureWorktreeDir(projectRoot: string): void {\n  const worktreePath = join(projectRoot, WORKTREE_DIR);\n  if (!existsSync(worktreePath)) {\n    info(`Creating ${WORKTREE_DIR}/ directory`);\n    mkdirSync(worktreePath, { recursive: true });\n    success(`Created ${WORKTREE_DIR}/ directory`);\n  }\n}\n\nfunction setupPrerequisites(projectRoot: string): void {\n  ensureGitignore(projectRoot, WORKTREE_DIR);\n  ensureWorktreeDir(projectRoot);\n  fetchRemote();\n}\n\n// Existing worktree handler\n\nfunction handleExistingWorktree(\n  worktreePath: string,\n  dirName: string,\n  options: CreateWorktreeOptions\n): void {\n  const setupMode: SetupMode = options.skipSetup\n    ? 'none'\n    : options.setupScript || 'default';\n\n  if (!runSetup(worktreePath, setupMode)) {\n    process.exit(1);\n  }\n\n  const branchInfo = getBranchInfo(worktreePath);\n  const branchDesc = branchInfo.tracking\n    ? `${branchInfo.branch} \u2192 ${branchInfo.tracking}`\n    : branchInfo.branch;\n\n  console.log('');\n  success(`Worktree ready: ${WORKTREE_DIR}/${dirName}`);\n  detail(`Branch: ${branchDesc}`);\n  console.log('');\n}\n\n// Main command: create worktree\n\nexport function createWorktree(\n  branch: string,\n  options: CreateWorktreeOptions\n): void {\n  const { projectRoot, dirName, worktreePath } = prepareWorktreePaths(branch);\n\n  // Early return for existing worktree\n  if (existsSync(worktreePath)) {\n    handleExistingWorktree(worktreePath, dirName, options);\n    return;\n  }\n\n  // Create new worktree\n  setupPrerequisites(projectRoot);\n\n  const resolution = resolveBranch(branch);\n\n  // Dispatch to appropriate handler based on branch type\n  switch (resolution.type) {\n    case 'remote':\n      createFromRemoteBranch(worktreePath, resolution);\n      break;\n    case 'local':\n      createFromLocalBranch(worktreePath, resolution);\n      break;\n    case 'new':\n      createNewBranch(worktreePath, resolution, options.baseBranch);\n      break;\n  }\n\n  // Run setup (if not skipped)\n  const setupMode: SetupMode = options.skipSetup\n    ? 'none'\n    : options.setupScript || 'default';\n\n  if (!runSetup(worktreePath, setupMode)) {\n    process.exit(1);\n  }\n\n  // Show summary\n  const branchInfo = getBranchInfo(worktreePath);\n  const branchDesc = branchInfo.tracking\n    ? `${branchInfo.branch} \u2192 ${branchInfo.tracking}`\n    : branchInfo.branch;\n\n  console.log('');\n  success(`Worktree ready: ${WORKTREE_DIR}/${dirName}`);\n  detail(`Branch: ${branchDesc}`);\n  console.log('');\n}\n\n// Remove worktree\n\nexport function removeWorktree(name: string): void {\n  const projectRoot = getProjectRoot();\n  const worktreePath = join(projectRoot, WORKTREE_DIR, name);\n\n  // Check if worktree exists\n  if (!existsSync(worktreePath)) {\n    error(`Worktree not found: ${WORKTREE_DIR}/${name}`);\n    info('Available worktrees:');\n    execInteractive('git worktree list');\n    process.exit(1);\n  }\n\n  // Get the branch name for this worktree\n  const branchName = execQuiet(`cd \"${worktreePath}\" && git rev-parse --abbrev-ref HEAD`);\n\n  // Remove worktree and branch\n  exec(`git worktree remove \"${worktreePath}\" --force`);\n\n  // Delete the local branch if it exists\n  let deletedBranch = false;\n  if (branchName && branchName !== 'HEAD') {\n    const result = execQuiet(`git branch -D \"${branchName}\"`);\n    deletedBranch = !!result;\n  }\n\n  // Show summary\n  console.log('');\n  success(`Removed: ${WORKTREE_DIR}/${name}`);\n  if (deletedBranch) {\n    detail(`Deleted branch: ${branchName}`);\n  }\n  console.log('');\n  execInteractive('git worktree list');\n}\n\n// List worktrees\n\nexport function listWorktrees(): void {\n  info('Git worktrees:');\n  console.log('');\n  execInteractive('git worktree list');\n}\n\n// Prune worktrees\n\nexport function pruneWorktrees(): void {\n  info('Pruning stale worktrees');\n  execInteractive('git worktree prune -v');\n  success('Stale worktrees pruned');\n  console.log('');\n  listWorktrees();\n}\n", "import { existsSync, accessSync, constants, readFileSync } from 'node:fs';\nimport { execSync } from 'node:child_process';\nimport { join } from 'node:path';\nimport { info, warning, success, error } from './logger.js';\n\nexport type SetupMode = 'none' | 'default' | string;\n\n/**\n * Detects setup script in worktree using industry-standard patterns.\n * Checks in priority order:\n * 1. script/setup (GitHub STRTA)\n * 2. script/bootstrap (GitHub STRTA)\n * 3. bin/setup (Ruby/Rails)\n * 4. setup.sh (project root)\n * 5. bootstrap.sh (project root)\n * 6. scripts/setup.sh\n * 7. scripts/bootstrap.sh\n * 8. Makefile (with setup/bootstrap target)\n *\n * @param worktreePath - Absolute path to worktree\n * @returns Path to detected script, or null if none found\n */\nfunction detectSetupScript(worktreePath: string): string | null {\n  const candidates = [\n    'script/setup',\n    'script/bootstrap',\n    'bin/setup',\n    'setup.sh',\n    'bootstrap.sh',\n    'scripts/setup.sh',\n    'scripts/bootstrap.sh',\n  ];\n\n  for (const candidate of candidates) {\n    const fullPath = join(worktreePath, candidate);\n    if (isExecutable(fullPath)) {\n      return fullPath;\n    }\n  }\n\n  // Check Makefile as fallback\n  const makefilePath = join(worktreePath, 'Makefile');\n  if (hasMakeTarget(makefilePath, ['setup', 'bootstrap'])) {\n    return 'make setup';\n  }\n\n  return null;\n}\n\n/**\n * Checks if a file exists and is executable\n */\nfunction isExecutable(filePath: string): boolean {\n  try {\n    accessSync(filePath, constants.F_OK | constants.X_OK);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Checks if Makefile has one of the specified targets\n */\nfunction hasMakeTarget(makefilePath: string, targets: string[]): boolean {\n  if (!existsSync(makefilePath)) {\n    return false;\n  }\n\n  try {\n    const content = readFileSync(makefilePath, 'utf-8');\n    // Check for lines like \".PHONY: setup\" or \"setup:\" etc\n    for (const target of targets) {\n      // Match lines starting with target name followed by colon\n      // This is a simple check; doesn't handle all Makefile edge cases\n      if (new RegExp(`^${target}:`, 'm').test(content)) {\n        return true;\n      }\n    }\n  } catch {\n    return false;\n  }\n\n  return false;\n}\n\nexport function runSetup(worktreePath: string, setupMode: SetupMode): boolean {\n  if (setupMode === 'none') {\n    info('Skipping setup (--no-setup flag set)');\n    return true;\n  }\n\n  console.log('');\n\n  let setupScript: string | null;\n\n  if (setupMode === 'default') {\n    // Auto-detect setup script\n    setupScript = detectSetupScript(worktreePath);\n\n    if (!setupScript) {\n      info('No setup script found (checked: script/setup, script/bootstrap, bin/setup, setup.sh, etc.)');\n      info('To use a custom script, run: workspace <branch> -s /path/to/script.sh');\n      return true;\n    }\n\n    success(`Found setup script: ${setupScript}`);\n  } else {\n    // User specified custom script - use as-is\n    setupScript = setupMode;\n  }\n\n  // Check if setup script exists\n  if (!existsSync(setupScript)) {\n    warning(`Setup script not found: ${setupScript}`);\n    return true;\n  }\n\n  // Check if setup script is executable\n  try {\n    accessSync(setupScript, constants.X_OK);\n  } catch {\n    warning(`Setup script is not executable: ${setupScript}`);\n    info(`Run: chmod +x ${setupScript}`);\n    return true;\n  }\n\n  // Execute setup script\n  console.log('');\n  info(`Running setup script: ${setupScript}`);\n  const startTime = Date.now();\n  try {\n    execSync(`\"${setupScript}\"`, {\n      stdio: 'inherit',\n      env: {\n        ...process.env,\n        WORKSPACE_DIR: worktreePath,\n      },\n    });\n\n    const duration = Math.floor((Date.now() - startTime) / 1000);\n    success(`Setup complete! (${duration}s)`);\n    return true;\n  } catch {\n    error('Setup script exited with error');\n    warning('Worktree created but setup failed');\n    return false;\n  }\n}\n"],
  "mappings": "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",
  "names": ["existsSync", "join", "existsSync", "readFileSync", "execSync", "join", "join", "existsSync", "readFileSync", "execSync", "join", "existsSync"]
}
